[
  {
    "path": "posts/2022-11-15-class-3-reshaping-data-into-a-tidy-format/",
    "title": "Class 3: Reshaping data into a tidy format",
    "description": {},
    "author": [
      {
        "name": "Kent Riemondy",
        "url": "https://github.com/kriemo"
      }
    ],
    "date": "2022-12-02",
    "categories": [],
    "contents": "\n\n\n\nThe Rmarkdown for this class is on github\nGoals for today\nDiscuss wide and long (tidy) data representations for analysis\nIntroduce tidyr for “tidying” rectangular data\nJoining related tables with dplyr\nStrategies for missing data\n\n“Data Scientists spend up to 80% of the time on data cleaning and 20 percent of their time on actual data analysis.”\n– Exploratory Data Mining and Data Cleaning. Dasu and Johnson\n\nWide versus long data formats\nData can be represented in multiple formats. Today we will discuss two common tabular formats for organizing data for analysis in R. Consider the following dataset, which contains GDP estimates per person for countries throughout history. This representation of the data is commonly referred to as ‘wide’ data format, which is a matrix-like format containing samples or features as rows or columns, with values associated with each sample and feature.\n\n# A tibble: 195 × 252\n   country `1799` `1800` `1801` `1802` `1803` `1804` `1805` `1806` `1807` `1808`\n   <chr>    <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n 1 Afghan…    683    683    683    683    683    683    683    683    683    683\n 2 Angola     700    702    705    709    711    714    718    721    725    727\n 3 Albania    755    755    755    755    755    756    756    756    756    756\n 4 Andorra   1360   1360   1360   1360   1370   1370   1370   1370   1380   1380\n 5 United…   1130   1130   1140   1140   1150   1150   1160   1160   1160   1170\n 6 Argent…   1730   1730   1740   1740   1750   1760   1760   1770   1770   1780\n 7 Armenia    582    582    582    582    582    582    582    582    582    582\n 8 Antigu…    857    857    857    857    857    857    857    858    858    858\n 9 Austra…    925    930    936    941    947    952    956    962    968    973\n10 Austria   2090   2100   2110   2120   2130   2130   2140   2150   2160   2170\n# … with 185 more rows, and 241 more variables: `1809` <dbl>, `1810` <dbl>,\n#   `1811` <dbl>, `1812` <dbl>, `1813` <dbl>, `1814` <dbl>, `1815` <dbl>,\n#   `1816` <dbl>, `1817` <dbl>, `1818` <dbl>, `1819` <dbl>, `1820` <dbl>,\n#   `1821` <dbl>, `1822` <dbl>, `1823` <dbl>, `1824` <dbl>, `1825` <dbl>,\n#   `1826` <dbl>, `1827` <dbl>, `1828` <dbl>, `1829` <dbl>, `1830` <dbl>,\n#   `1831` <dbl>, `1832` <dbl>, `1833` <dbl>, `1834` <dbl>, `1835` <dbl>,\n#   `1836` <dbl>, `1837` <dbl>, `1838` <dbl>, `1839` <dbl>, `1840` <dbl>, …\n\nThe wide matrix-like format is very useful and a common format used for statistics and machine learning. Matrices can take advantage of optimized numerical routines and are the data representation of mathematical matrices. We will work with matrices later in class, particularly with their use to generate heatmaps.\nRepresenting data in a matrix has a few practical implications:\nThere is only 1 type of data stored in matrix (e.g. each cell is the same unit of observation, the GDP per person). To store more values you need multiple matrices.\nThe format is not easily manipulated with dplyr/tidyverse.\nData in a matrix can be instead formatted in a long (aka “tidy”) format.\n\n# A tibble: 48,945 × 3\n   country     year    gdp\n   <chr>       <chr> <dbl>\n 1 Afghanistan 1799    683\n 2 Afghanistan 1800    683\n 3 Afghanistan 1801    683\n 4 Afghanistan 1802    683\n 5 Afghanistan 1803    683\n 6 Afghanistan 1804    683\n 7 Afghanistan 1805    683\n 8 Afghanistan 1806    683\n 9 Afghanistan 1807    683\n10 Afghanistan 1808    683\n# … with 48,935 more rows\n\nThe long format of this data simplifies the many columns of a matrix into a 3 column data.frame containing 3 variables (country, year, and gdp).\nTidy data format\n\n“Tidy datasets are all alike, but every messy dataset is messy in its own way.” –– Hadley Wickham\n\nTidy data is a concept introduced by Hadley Wickham, chief scientist at Rstudio, and developer of many of the tidyverse packages. A tidy dataset is structured in a manner to be most effectively processed in R using the tidyverse. It makes the data easier to plot, easier to perform computations and perform complex tasks.\nMost data tables that you’ve worked with are probably not tidy. It takes experience to understand the best way to format the data. As you work more in R and the tidyverse this will become more natural.\nTidy data has the following attributes:\nEach variable must have its own column.\nEach observation must have its own row.\nEach value must have its own cell.\nWhat is a variable, what is an observation, and what is a value?\nA value is a number or word.\nEvery value belongs to a variable and an observation\nA variable contains all values that measure the same attribute (e.g. height, temperature, duration, magnitude) across units.\nAn observation contains all values measured on the same unit (e.g. the same individual, day, country, gene).\n\n\n\nShown below is a simple data table in a tidy format, provided by the tidyr package.\n\n\nlibrary(tidyr)\ntable1\n\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <int>  <int>      <int>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\nThe same data, represented in wide, matrix-like format, would require 2 tables:\ne.g a matrix with the cases values per country.\n\n\ntable4a\n\n# A tibble: 3 × 3\n  country     `1999` `2000`\n* <chr>        <int>  <int>\n1 Afghanistan    745   2666\n2 Brazil       37737  80488\n3 China       212258 213766\n\ne.g a matrix with the population values per country\n\n\ntable4b\n\n# A tibble: 3 × 3\n  country         `1999`     `2000`\n* <chr>            <int>      <int>\n1 Afghanistan   19987071   20595360\n2 Brazil       172006362  174504898\n3 China       1272915272 1280428583\n\nWhat advantages does the tidy format provide?\nEasy to generate summaries of the data.\ne.g. via group_by() -> summarize()\nEasy to plot the data using the ggplot2 framework (more on that in later classes)\nVery easy to join multiple data tables based on key values.\nSome disadvantages:\nNot space efficient\nNot intuitive\nDoesn’t interface well with traditional machine learning and statistical approaches.\nConverting between long and wide formats using tidyr\nThe tidyr package provides functionality to convert datasets into tidy formats.\npivot_longer(): convert wide data to long data\npivot_wider(): convert long data to wide data\nseparate(): split a single column into multiple columns\nunite(): combine multiple columns into single columns\nReshaping wide data to long\nThe pivot_longer function requires specifying the columns to pivot using the tidyselect syntax. This syntax is used elsewhere in the tidyverse and is a useful shorthand to avoid listing all columns of interest.\npivot_longer(tbl, cols = <...>)\n\n\n\nFigure 1: Tables from tidyr cheatsheet from https://posit.co/wp-content/uploads/2022/10/tidyr.pdf\n\n\n\n\n\npivot_longer(table4a, cols = `1999`:`2000`) # pivot columns from 1999 -> 2000\n\n# A tibble: 6 × 3\n  country     name   value\n  <chr>       <chr>  <int>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\npivot_longer(table4a, cols = -country) # pivot all columns not matching country\n\n# A tibble: 6 × 3\n  country     name   value\n  <chr>       <chr>  <int>\n1 Afghanistan 1999     745\n2 Afghanistan 2000    2666\n3 Brazil      1999   37737\n4 Brazil      2000   80488\n5 China       1999  212258\n6 China       2000  213766\n\nReshaping long data to wide\npivot_wider(tbl, names_from = <...>, values_from = <...>)\nnames_from: the column whose values will become new columns in the result.values_from: the column whose values will be in the new columns.\n\n\n\n\n\npivot_wider(table2, names_from = type, values_from = count)\n\n# A tibble: 6 × 4\n  country      year  cases population\n  <chr>       <int>  <int>      <int>\n1 Afghanistan  1999    745   19987071\n2 Afghanistan  2000   2666   20595360\n3 Brazil       1999  37737  172006362\n4 Brazil       2000  80488  174504898\n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\nSeparate\nseparate is useful for dealing with data in which a single column contains multiple variables.\nseperate(tbl, col = <...>, into = c(<..., ..., ...>), sep = \"...\")\ncol: column to split into multiple columnsinto: column names of new columns to be generated, supplied as a character vector (use quotes).sep: the separator used to split values in the col column. Can be a character (_) or a integer to indicate the character position to split (2).\n\n\n\n\n\nseparate(table3, col = rate, into = c(\"cases\", \"pop\"), sep = \"/\")\n\n# A tibble: 6 × 4\n  country      year cases  pop       \n  <chr>       <int> <chr>  <chr>     \n1 Afghanistan  1999 745    19987071  \n2 Afghanistan  2000 2666   20595360  \n3 Brazil       1999 37737  172006362 \n4 Brazil       2000 80488  174504898 \n5 China        1999 212258 1272915272\n6 China        2000 213766 1280428583\n\nunite\nunite is the inverse operation of separate and will join multiple columns together. You can also use str_c from stringr or paste() from base R with mutate.\n\n\n\n\n\nunite(table5, \"year\", century:year, sep = \"\")\n\n# A tibble: 6 × 3\n  country     year  rate             \n  <chr>       <chr> <chr>            \n1 Afghanistan 1999  745/19987071     \n2 Afghanistan 2000  2666/20595360    \n3 Brazil      1999  37737/172006362  \n4 Brazil      2000  80488/174504898  \n5 China       1999  212258/1272915272\n6 China       2000  213766/1280428583\n\n#mutate(table5, year = str_c(century, year))\n\n\nExercises\nUse the gapminder GDP dataset to perform the following tasks and answer the following quesitons:\nConvert the GDP dataset into tidy format.\n\n\nlibrary(tidyverse)\ngdp_data <- read_csv(\"data/income_per_person.csv\")\npivot_longer(gdp_data, cols = `1799`:`2049`)\n\n# A tibble: 48,945 × 3\n   country     name  value\n   <chr>       <chr> <dbl>\n 1 Afghanistan 1799    683\n 2 Afghanistan 1800    683\n 3 Afghanistan 1801    683\n 4 Afghanistan 1802    683\n 5 Afghanistan 1803    683\n 6 Afghanistan 1804    683\n 7 Afghanistan 1805    683\n 8 Afghanistan 1806    683\n 9 Afghanistan 1807    683\n10 Afghanistan 1808    683\n# … with 48,935 more rows\n\ngdp_tidy <- pivot_longer(gdp_data, \n                         cols = -country, \n                         names_to = \"year\", \n                         values_to = \"gdp\")\ngdp_tidy\n\n# A tibble: 48,945 × 3\n   country     year    gdp\n   <chr>       <chr> <dbl>\n 1 Afghanistan 1799    683\n 2 Afghanistan 1800    683\n 3 Afghanistan 1801    683\n 4 Afghanistan 1802    683\n 5 Afghanistan 1803    683\n 6 Afghanistan 1804    683\n 7 Afghanistan 1805    683\n 8 Afghanistan 1806    683\n 9 Afghanistan 1807    683\n10 Afghanistan 1808    683\n# … with 48,935 more rows\n\nWhich country had the highest GDP per person in 1985?\n\n\n# using the wide data\nslice_max(gdp_data, `1985`)\n\n# A tibble: 1 × 252\n  country `1799` `1800` `1801` `1802` `1803` `1804` `1805` `1806` `1807` `1808`\n  <chr>    <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>  <dbl>\n1 Brunei    1710   1710   1710   1710   1710   1710   1710   1710   1710   1710\n# … with 241 more variables: `1809` <dbl>, `1810` <dbl>, `1811` <dbl>,\n#   `1812` <dbl>, `1813` <dbl>, `1814` <dbl>, `1815` <dbl>, `1816` <dbl>,\n#   `1817` <dbl>, `1818` <dbl>, `1819` <dbl>, `1820` <dbl>, `1821` <dbl>,\n#   `1822` <dbl>, `1823` <dbl>, `1824` <dbl>, `1825` <dbl>, `1826` <dbl>,\n#   `1827` <dbl>, `1828` <dbl>, `1829` <dbl>, `1830` <dbl>, `1831` <dbl>,\n#   `1832` <dbl>, `1833` <dbl>, `1834` <dbl>, `1835` <dbl>, `1836` <dbl>,\n#   `1837` <dbl>, `1838` <dbl>, `1839` <dbl>, `1840` <dbl>, `1841` <dbl>, …\n\n# using the long tidy data\ngdp_tidy %>% \n  filter(year == \"1985\") %>% \n  arrange(desc(gdp)) %>% \n  slice(1)\n\n# A tibble: 1 × 3\n  country year    gdp\n  <chr>   <chr> <dbl>\n1 Brunei  1985  77900\n\nWhat was the mean worldwide GDP in the year 1999?\n\n\n# using the tidy data\ngdp_tidy %>% \n  filter(year == \"1999\") %>% \n  summarize(mean_gdp = mean(gdp))\n\n# A tibble: 1 × 1\n  mean_gdp\n     <dbl>\n1   15202.\n\ngdp_tidy %>% \n  filter(year == \"1999\") %>% \n  pull(gdp) %>% \n  mean()\n\n[1] 15201.59\n\n# using the wide data\ngdp_data$`1999` %>% \n  mean()\n\n[1] 15201.59\n\nmean(gdp_data$`1999`)\n\n[1] 15201.59\n\nWhich country had the highest average GDP in the 19th century?\n\n\ngdp_tidy %>% \n  filter(str_detect(year, \"^18\")) %>% \n  group_by(country) %>% \n  summarize(avg_gdp = mean(gdp)) %>% \n  arrange(desc(avg_gdp))\n\n# A tibble: 195 × 2\n   country        avg_gdp\n   <chr>            <dbl>\n 1 United Kingdom   5531.\n 2 United States    4993.\n 3 Netherlands      4604.\n 4 Australia        4118.\n 5 Belgium          4079.\n 6 Switzerland      3667.\n 7 New Zealand      3501.\n 8 Monaco           3454.\n 9 Uruguay          3255.\n10 Denmark          3253 \n# … with 185 more rows\n\nBinds/Joins\ncolumn binds\n\n\n\nFigure 2: from the dplyr cheatsheet at https://posit.co/wp-content/uploads/2022/10/data-transformation-1.pdf\n\n\n\nbind_cols(tbl_1, tbl_2, ...)\nbind_cols will bind the columns from 2 or more tables into 1 table. Note that with column binds you need to ensure that each table has the same number of rows.\n\n\nlibrary(dplyr)\ntbl1 <- tibble(x = 1:3)\ntbl2 <- tibble(y = 3:5)\nbind_cols(tbl1, tbl2)\n\n# A tibble: 3 × 2\n      x     y\n  <int> <int>\n1     1     3\n2     2     4\n3     3     5\n\nrow binds\nbind_rows binds rows from multiple tables into one table. Unlike with bind_cols the number of columns doesn’t need to match when using bind_rows.\nbind_rows(tbl_1, tbl_2, ..., .id = NULL)\n\n\n\n\n\none <- starwars[1:4, 1:4]\ntwo <- starwars[9:12, 1:4]\n\nbind_rows(one, two)\n\n# A tibble: 8 × 4\n  name              height  mass hair_color   \n  <chr>              <int> <dbl> <chr>        \n1 Luke Skywalker       172    77 blond        \n2 C-3PO                167    75 <NA>         \n3 R2-D2                 96    32 <NA>         \n4 Darth Vader          202   136 none         \n5 Biggs Darklighter    183    84 black        \n6 Obi-Wan Kenobi       182    77 auburn, white\n7 Anakin Skywalker     188    84 blond        \n8 Wilhuff Tarkin       180    NA auburn, grey \n\nYou can also use a list of data.frames with bind_rows. If the list is named, you can use the .id argument to store a column specifying the name of the data.frame in the output.\n\n\nlst_of_dfs <- list(a = one,\n                   b = two)\nbind_rows(lst_of_dfs)\n\n# A tibble: 8 × 4\n  name              height  mass hair_color   \n  <chr>              <int> <dbl> <chr>        \n1 Luke Skywalker       172    77 blond        \n2 C-3PO                167    75 <NA>         \n3 R2-D2                 96    32 <NA>         \n4 Darth Vader          202   136 none         \n5 Biggs Darklighter    183    84 black        \n6 Obi-Wan Kenobi       182    77 auburn, white\n7 Anakin Skywalker     188    84 blond        \n8 Wilhuff Tarkin       180    NA auburn, grey \n\nbind_rows(lst_of_dfs, .id = \"source_table\")\n\n# A tibble: 8 × 5\n  source_table name              height  mass hair_color   \n  <chr>        <chr>              <int> <dbl> <chr>        \n1 a            Luke Skywalker       172    77 blond        \n2 a            C-3PO                167    75 <NA>         \n3 a            R2-D2                 96    32 <NA>         \n4 a            Darth Vader          202   136 none         \n5 b            Biggs Darklighter    183    84 black        \n6 b            Obi-Wan Kenobi       182    77 auburn, white\n7 b            Anakin Skywalker     188    84 blond        \n8 b            Wilhuff Tarkin       180    NA auburn, grey \n\nJoins\nJoin operations are used to join one table with another table by matching the values shared in particular columns. They are used join datasets with a shared variable.\nThere are multiple way to join two tables, depending on how you want to handle different combinations of values present in two tables.\nFrom the dplyr documentation:\nThe mutating joins add columns from y to x, matching rows based on the keys:\n\ninner_join(): includes all rows in x and y.\n\nleft_join(): includes all rows in x.\n\nright_join(): includes all rows in y.\n\nfull_join(): includes all rows in x or y.\n\nIf a row in x matches multiple rows in y, all the rows in y will \nbe returned once for each matching row in x.\nConsider the following simple tables:\n\n\nband_members\n\n# A tibble: 3 × 2\n  name  band   \n  <chr> <chr>  \n1 Mick  Stones \n2 John  Beatles\n3 Paul  Beatles\n\n\n\nband_instruments\n\n# A tibble: 3 × 2\n  name  plays \n  <chr> <chr> \n1 John  guitar\n2 Paul  bass  \n3 Keith guitar\n\nExercise:\nPerform an inner, left, and full join of the band_members and band_instruments:\n\n\ninner_join(band_members, band_instruments)\n\n# A tibble: 2 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 John  Beatles guitar\n2 Paul  Beatles bass  \n\nleft_join(band_members, band_instruments)\n\n# A tibble: 3 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n\nfull_join(band_members, band_instruments)\n\n# A tibble: 4 × 3\n  name  band    plays \n  <chr> <chr>   <chr> \n1 Mick  Stones  <NA>  \n2 John  Beatles guitar\n3 Paul  Beatles bass  \n4 Keith <NA>    guitar\n\nThe Joining, by = \"name\" message indicates which columns were used to determine matching rows between the two tables. This is auto-detected based on shared column names. You can use the by argument to explicitly specify the columns you’d like to join, which is useful if the columns of interest have different names in the two tables.\nMissing data\nJoin operations will often generate missing data (e.g. NAs).\nZeroes, NA, NaN and NULL\nDon’t use use zeroes to represent missing data. 0 is valid observed value.\nNA (Not Available) is most often use to represent missing data.\nNaN (Not a Number) is the result of an undefined operation, e.g. 0 / 0.\nNULL means “undefined” and is only used in a programming context (i.e., a function that returns NULL). You can’t put NULL values in a data frame.\nLet’s examine a data frame with some missing data.\n\n\nstarwars\n\n# A tibble: 87 × 14\n   name        height  mass hair_…¹ skin_…² eye_c…³ birth…⁴ sex   gender homew…⁵\n   <chr>        <int> <dbl> <chr>   <chr>   <chr>     <dbl> <chr> <chr>  <chr>  \n 1 Luke Skywa…    172    77 blond   fair    blue       19   male  mascu… Tatooi…\n 2 C-3PO          167    75 <NA>    gold    yellow    112   none  mascu… Tatooi…\n 3 R2-D2           96    32 <NA>    white,… red        33   none  mascu… Naboo  \n 4 Darth Vader    202   136 none    white   yellow     41.9 male  mascu… Tatooi…\n 5 Leia Organa    150    49 brown   light   brown      19   fema… femin… Aldera…\n 6 Owen Lars      178   120 brown,… light   blue       52   male  mascu… Tatooi…\n 7 Beru White…    165    75 brown   light   blue       47   fema… femin… Tatooi…\n 8 R5-D4           97    32 <NA>    white,… red        NA   none  mascu… Tatooi…\n 9 Biggs Dark…    183    84 black   light   brown      24   male  mascu… Tatooi…\n10 Obi-Wan Ke…    182    77 auburn… fair    blue-g…    57   male  mascu… Stewjon\n# … with 77 more rows, 4 more variables: species <chr>, films <list>,\n#   vehicles <list>, starships <list>, and abbreviated variable names\n#   ¹​hair_color, ²​skin_color, ³​eye_color, ⁴​birth_year, ⁵​homeworld\n\nfilter with is.na()\nYou can identify variables with NA values by combining filter() and is.na().\n\n\n# find rows where mass is NA\nfilter(starwars, is.na(mass))\n\n# find rows where mass is *not* NA\nfilter(starwars, !is.na(mass))\n\n\nna.omit()\nYou can remove all rows containing NA values with na.omit().\n\n\nna.omit(starwars)\n\n\nComputing with NA values\nExclude NA values from operations with na.rm = TRUE.\n\n\nstarwars$mass\n# if NAs are present, the result is NA\nsum(starwars$mass)\n# solution: drop NAs from the calculation\nsum(starwars$mass, na.rm = TRUE)\n\n\n\n\ngroup_by(starwars, species) %>% \n  summarize(avg_mass = mean(mass, na.rm = TRUE))\n\n\nAlso you can remove NaN values by detecting for their presence using is.nan(). These values occur because a few species don’t have any characters with values for the mass column, and computing the mean of an empty vector is NaN.\n\n\ngroup_by(starwars, species) %>% \n  summarize(avg_mass = mean(mass, na.rm = TRUE)) %>% \n  filter(!is.nan(avg_mass))\n\n# A tibble: 32 × 2\n   species   avg_mass\n   <chr>        <dbl>\n 1 Aleena        15  \n 2 Besalisk     102  \n 3 Cerean        82  \n 4 Clawdite      55  \n 5 Droid         69.8\n 6 Dug           40  \n 7 Ewok          20  \n 8 Geonosian     80  \n 9 Gungan        74  \n10 Human         82.8\n# … with 22 more rows\n\nReplacing NA values\nLet’s replace the NA vaues in hair_color with a string missing data.\n\n\nstarwars %>% \n  mutate(new_hair_color = ifelse(is.na(hair_color), \n                                 \"missing data\",\n                                 hair_color)) %>% \n  select(hair_color, new_hair_color)\n\n# A tibble: 87 × 2\n   hair_color    new_hair_color\n   <chr>         <chr>         \n 1 blond         blond         \n 2 <NA>          missing data  \n 3 <NA>          missing data  \n 4 none          none          \n 5 brown         brown         \n 6 brown, grey   brown, grey   \n 7 brown         brown         \n 8 <NA>          missing data  \n 9 black         black         \n10 auburn, white auburn, white \n# … with 77 more rows\n\nWe can also replace with values from another column, such as species.\n\n\nstarwars %>% \n  mutate(new_hair_color = ifelse(is.na(hair_color), \n                                 species,\n                                 hair_color)) %>% \n  select(hair_color, new_hair_color)\n\n# A tibble: 87 × 2\n   hair_color    new_hair_color\n   <chr>         <chr>         \n 1 blond         blond         \n 2 <NA>          Droid         \n 3 <NA>          Droid         \n 4 none          none          \n 5 brown         brown         \n 6 brown, grey   brown, grey   \n 7 brown         brown         \n 8 <NA>          Droid         \n 9 black         black         \n10 auburn, white auburn, white \n# … with 77 more rows\n\nifelse is a base R function that operates on vectors and is useful when you want to replace single values.\ncase_when()\nIf you want to perform more complex operations use case_when() from dplyr. case_when() is equivalent to performing multiple nested ifelse() operations, whereby if the first operation is not TRUE, then check for the second condition, repeating for each condition until there are no more statements.\nthe syntax for case when is :\n`case_when(conditional statement ~ \"value in result\",\n           conditional statement #2 ~ \"another value in result\",\n           TRUE ~ \"default if neither conditional statement 1 or 2 are TRUE\")`\nHere is an example from the documentation. Make a new column called type. Return “large” if the height or mass of a character is > 200. If that is not true, then return “robot” if the species is “Droid”. If that is not TRUE, then default to returning “other”.\n\n\nstarwars %>%\n  select(name:mass, species) %>%\n  mutate(type = case_when(height > 200 | mass > 200 ~ \"large\",\n                          species == \"Droid\"        ~ \"robot\",\n                          TRUE                      ~ \"other\"))\n\n# A tibble: 87 × 5\n   name               height  mass species type \n   <chr>               <int> <dbl> <chr>   <chr>\n 1 Luke Skywalker        172    77 Human   other\n 2 C-3PO                 167    75 Droid   robot\n 3 R2-D2                  96    32 Droid   robot\n 4 Darth Vader           202   136 Human   large\n 5 Leia Organa           150    49 Human   other\n 6 Owen Lars             178   120 Human   other\n 7 Beru Whitesun lars    165    75 Human   other\n 8 R5-D4                  97    32 Droid   robot\n 9 Biggs Darklighter     183    84 Human   other\n10 Obi-Wan Kenobi        182    77 Human   other\n# … with 77 more rows\n\nUsing group_by() to replace NAs with summaries from the data\nLastly, it may be beneficial to replace the NA values with a summary value representative of the data. This is an example of data “imputation”.\nFor example we might decide that we want to replace NA values in the “mass” column with the average mass of the species of the character.\nUsing group_by() + mutate() is a useful paradigm for performing this operation:\n\n\nstarwars %>% \n  select(name, mass, species) %>% \n  group_by(species) %>% \n  mutate(avg_mass = mean(mass, na.rm = TRUE)) %>% \n  mutate(imputed_mass = ifelse(is.na(mass), avg_mass, mass))\n\n# A tibble: 87 × 5\n# Groups:   species [38]\n   name                mass species avg_mass imputed_mass\n   <chr>              <dbl> <chr>      <dbl>        <dbl>\n 1 Luke Skywalker        77 Human       82.8           77\n 2 C-3PO                 75 Droid       69.8           75\n 3 R2-D2                 32 Droid       69.8           32\n 4 Darth Vader          136 Human       82.8          136\n 5 Leia Organa           49 Human       82.8           49\n 6 Owen Lars            120 Human       82.8          120\n 7 Beru Whitesun lars    75 Human       82.8           75\n 8 R5-D4                 32 Droid       69.8           32\n 9 Biggs Darklighter     84 Human       82.8           84\n10 Obi-Wan Kenobi        77 Human       82.8           77\n# … with 77 more rows\n\n\nShow session info\n\n\nsessionInfo()\n\nR version 4.2.0 (2022-04-22)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur/Monterey 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] forcats_0.5.1   stringr_1.4.1   dplyr_1.0.10    purrr_0.3.5    \n[5] tibble_3.1.8    ggplot2_3.3.6   tidyverse_1.3.1 tidyr_1.2.0    \n[9] readr_2.1.2    \n\nloaded via a namespace (and not attached):\n [1] lubridate_1.8.0  assertthat_0.2.1 digest_0.6.30    utf8_1.2.2      \n [5] R6_2.5.1         cellranger_1.1.0 backports_1.4.1  reprex_2.0.1    \n [9] evaluate_0.16    httr_1.4.4       highr_0.9        pillar_1.8.1    \n[13] rlang_1.0.6      readxl_1.4.0     rstudioapi_0.13  jquerylib_0.1.4 \n[17] rmarkdown_2.14   bit_4.0.4        munsell_0.5.0    broom_0.8.0     \n[21] compiler_4.2.0   modelr_0.1.8     xfun_0.32        pkgconfig_2.0.3 \n[25] htmltools_0.5.2  downlit_0.4.2    tidyselect_1.2.0 fansi_1.0.3     \n[29] crayon_1.5.2     tzdb_0.3.0       dbplyr_2.2.1     withr_2.5.0     \n[33] grid_4.2.0       jsonlite_1.8.3   gtable_0.3.0     lifecycle_1.0.3 \n[37] DBI_1.1.3        magrittr_2.0.3   scales_1.2.0     cli_3.4.1       \n[41] stringi_1.7.8    vroom_1.5.7      cachem_1.0.6     fs_1.5.2        \n[45] xml2_1.3.3       bslib_0.3.1      ellipsis_0.3.2   generics_0.1.3  \n[49] vctrs_0.4.1      distill_1.5      tools_4.2.0      bit64_4.0.5     \n[53] glue_1.6.2       hms_1.1.2        parallel_4.2.0   fastmap_1.1.0   \n[57] yaml_2.3.6       colorspace_2.0-3 rvest_1.0.2      memoise_2.0.1   \n[61] knitr_1.39       haven_2.5.0      sass_0.4.1      \n\nAcknowledgements and additional references\nThe content of this class borrows heavily from previous tutorials:\nTutorial organization:\nhttps://github.com/sjaganna/molb7910-2019\nR tutorials and documentation:\nhttps://github.com/tidyverse/dplyr\nhttps://r4ds.had.co.nz/index.html\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-04T04:23:17+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-10-04-class-2/",
    "title": "Class 2: Data wrangling with the tidyverse",
    "description": {},
    "author": [
      {
        "name": "Kent Riemondy",
        "url": "https://github.com/kriemo"
      }
    ],
    "date": "2022-12-01",
    "categories": [],
    "contents": "\n\nContents\nIntroduction to the tidyverse\nloading R packages\ntibble versus data.frame\nConvertly a typical data.frame to a tibble\nExploring data\n\nData import using readr\nData import/export for excel files\nData import/export of R objects\nGrammar for data manipulation: dplyr\nChaining operations\nFilter rows\narrange rows\n\nColumn operations\nselect columns\n\nWhen to quote or not quote?\nAdding new columns with mutate\nSummarizing columns\nGrouped operations\nString manipulation\nAcknowledgements and additional references\n\nThe Rmarkdown for this class is on github\nIntroduction to the tidyverse\nThe tidyverse is a collection of packages that share similar design philosophy, syntax, and data structures. The packages are largely developed by the same team that builds Rstudio.\nSome key packages that we will touch on in this course:\nggplot2: plotting based on the “grammar of graphics”dplyr: functions to manipulate tabular datatidyr: functions to help reshape data into a tidy formatreadr: functions for data import and exportstringr: functions for working with stringstibble: a redesigned data.frame\nloading R packages\nTo use an R package in an analysis we need to load the package using the library() function. This needs to be done once in each R session and it is a good idea to do this at the beginning of your Rmarkdown. For teaching purposes I will however sometimes load a package when I introduce a function from a package.\n\n\nlibrary(readr)\nlibrary(dplyr)\nlibrary(tibble)\n\n\ntibble versus data.frame\nA tibble is a reimagining of the base R data.frame. It has a few differences from the data.frame.The biggest differences are that it doesn’t have row.names and it has an enhanced print method. If interested in learning more, see the tibble vignette.\nCompare data to data_tbl.\nNote, by default Rstudio displays data.frames in a tibble-like format\n\n\ndata <- data.frame(a = 1:3, \n                   b = letters[1:3], \n                   c = Sys.Date() - 1:3, \n                   row.names = c(\"a\", \"b\", \"c\"))\ndata_tbl <- as_tibble(data)\ndata_tbl\n\n\nWhen you work with tidyverse functions it is a good practice to convert data.frames to tibbles.\nConvertly a typical data.frame to a tibble\nIf a data.frame has rownames, you can preserve these by moving them into a column before converting to a tibble using the rownames_to_column() from tibble.\n\n\nmtcars # built in dataset, a data.frame with information about vehicles\n\n                     mpg cyl  disp  hp drat    wt  qsec vs am gear carb\nMazda RX4           21.0   6 160.0 110 3.90 2.620 16.46  0  1    4    4\nMazda RX4 Wag       21.0   6 160.0 110 3.90 2.875 17.02  0  1    4    4\nDatsun 710          22.8   4 108.0  93 3.85 2.320 18.61  1  1    4    1\nHornet 4 Drive      21.4   6 258.0 110 3.08 3.215 19.44  1  0    3    1\nHornet Sportabout   18.7   8 360.0 175 3.15 3.440 17.02  0  0    3    2\nValiant             18.1   6 225.0 105 2.76 3.460 20.22  1  0    3    1\nDuster 360          14.3   8 360.0 245 3.21 3.570 15.84  0  0    3    4\nMerc 240D           24.4   4 146.7  62 3.69 3.190 20.00  1  0    4    2\nMerc 230            22.8   4 140.8  95 3.92 3.150 22.90  1  0    4    2\nMerc 280            19.2   6 167.6 123 3.92 3.440 18.30  1  0    4    4\nMerc 280C           17.8   6 167.6 123 3.92 3.440 18.90  1  0    4    4\nMerc 450SE          16.4   8 275.8 180 3.07 4.070 17.40  0  0    3    3\nMerc 450SL          17.3   8 275.8 180 3.07 3.730 17.60  0  0    3    3\nMerc 450SLC         15.2   8 275.8 180 3.07 3.780 18.00  0  0    3    3\nCadillac Fleetwood  10.4   8 472.0 205 2.93 5.250 17.98  0  0    3    4\nLincoln Continental 10.4   8 460.0 215 3.00 5.424 17.82  0  0    3    4\nChrysler Imperial   14.7   8 440.0 230 3.23 5.345 17.42  0  0    3    4\nFiat 128            32.4   4  78.7  66 4.08 2.200 19.47  1  1    4    1\nHonda Civic         30.4   4  75.7  52 4.93 1.615 18.52  1  1    4    2\nToyota Corolla      33.9   4  71.1  65 4.22 1.835 19.90  1  1    4    1\nToyota Corona       21.5   4 120.1  97 3.70 2.465 20.01  1  0    3    1\nDodge Challenger    15.5   8 318.0 150 2.76 3.520 16.87  0  0    3    2\nAMC Javelin         15.2   8 304.0 150 3.15 3.435 17.30  0  0    3    2\nCamaro Z28          13.3   8 350.0 245 3.73 3.840 15.41  0  0    3    4\nPontiac Firebird    19.2   8 400.0 175 3.08 3.845 17.05  0  0    3    2\nFiat X1-9           27.3   4  79.0  66 4.08 1.935 18.90  1  1    4    1\nPorsche 914-2       26.0   4 120.3  91 4.43 2.140 16.70  0  1    5    2\nLotus Europa        30.4   4  95.1 113 3.77 1.513 16.90  1  1    5    2\nFord Pantera L      15.8   8 351.0 264 4.22 3.170 14.50  0  1    5    4\nFerrari Dino        19.7   6 145.0 175 3.62 2.770 15.50  0  1    5    6\nMaserati Bora       15.0   8 301.0 335 3.54 3.570 14.60  0  1    5    8\nVolvo 142E          21.4   4 121.0 109 4.11 2.780 18.60  1  1    4    2\n\n\n\nmtcars_tbl <- rownames_to_column(mtcars, \"vehicle\")\nmtcars_tbl <- as_tibble(mtcars_tbl)\nmtcars_tbl\n\n# A tibble: 32 × 12\n   vehicle       mpg   cyl  disp    hp  drat    wt  qsec    vs    am  gear  carb\n   <chr>       <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl> <dbl>\n 1 Mazda RX4    21       6  160    110  3.9   2.62  16.5     0     1     4     4\n 2 Mazda RX4 …  21       6  160    110  3.9   2.88  17.0     0     1     4     4\n 3 Datsun 710   22.8     4  108     93  3.85  2.32  18.6     1     1     4     1\n 4 Hornet 4 D…  21.4     6  258    110  3.08  3.22  19.4     1     0     3     1\n 5 Hornet Spo…  18.7     8  360    175  3.15  3.44  17.0     0     0     3     2\n 6 Valiant      18.1     6  225    105  2.76  3.46  20.2     1     0     3     1\n 7 Duster 360   14.3     8  360    245  3.21  3.57  15.8     0     0     3     4\n 8 Merc 240D    24.4     4  147.    62  3.69  3.19  20       1     0     4     2\n 9 Merc 230     22.8     4  141.    95  3.92  3.15  22.9     1     0     4     2\n10 Merc 280     19.2     6  168.   123  3.92  3.44  18.3     1     0     4     4\n# … with 22 more rows\n\nIf you don’t need the rownames, then you can use the as_tibble() function directly.\n\n\nmtcars_tbl <- as_tibble(mtcars)\n\n\nExploring data\nView() can be used to open an excel like view of a data.frame. This is a good way to quickly look at the data. glimpse() or str() give an additional view of the data.\nView(mtcars)\nglimpse(mtcars)\nstr(mtcars)\nAdditional R functions to help with exploring data.frames (and tibbles):\n\n\ndim(mtcars) # of rows and columns\nnrow(mtcars)\nncol(mtcars)\n\nhead(mtcars) # first 6 lines\nhead(mtcars, n = 2)\ntail(mtcars) # last 6 lines\ncolnames(mtcars) # column names\nrownames(mtcars) # row names (not present in tibble)\n\n\nUseful base R functions for exploring values\n\n\nmtcars$gear # extract gear column data as a vector\nmtcars[, \"gear\"] # extract gear column data as a vector\nmtcars[[\"gear\"]] # extract gear column data as a vector\n\nsummary(mtcars$gear) # get summary stats on column\n\nunique(mtcars$cyl) # find unique values in column cyl\nlength(mtcars$cyl) # length of values in a vector\n  \ntable(mtcars$cyl) # get frequency of each value in column cyl\ntable(mtcars$gear, mtcars$cyl) # get frequency of each combination of values\n\n\nData import using readr\nThe readr package provides a series of functions for importing or writing data in common text formats.\nread_csv(): comma-separated values (CSV) filesread_tsv(): tab-separated values (TSV) filesread_delim(): delimited files (CSV and TSV are important special cases)read_fwf(): fixed-width filesread_table(): whitespace-separated files\nThese functions are faster and have better defaults than the base R equivalents (e.g. read.table). These functions also directly output tibbles compatible with the tidyverse.\nThe readr checksheet provides a concise overview of the functionality in the package.\nTo illustrate how to use readr we will load a .csv file containing information about flights from 2014.\nFirst we will download the data. You can download this data manually from github. Instead we will use R to download the dataset using the download.file() base R function.\n\n\nif(!file.exists(\"flights14.csv\")) {\n  url <- \"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv\" \n  download.file(url, \"flights14.csv\")\n}  \n\n\nYou should now have a file called “flights14.csv” in your working directory (the same directory as the Rmarkdown). To read this data into R, we can use the read_csv() function. The defaults for this function often work for many datasets.\n\n\nflights <- read_csv(\"flights14.csv\")\nflights\n\n# A tibble: 253,316 × 11\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       14      13 AA      JFK    LAX       359    2475     9\n 2  2014     1     1       -3      13 AA      JFK    LAX       363    2475    11\n 3  2014     1     1        2       9 AA      JFK    LAX       351    2475    19\n 4  2014     1     1       -8     -26 AA      LGA    PBI       157    1035     7\n 5  2014     1     1        2       1 AA      JFK    LAX       350    2475    13\n 6  2014     1     1        4       0 AA      EWR    LAX       339    2454    18\n 7  2014     1     1       -2     -18 AA      JFK    LAX       338    2475    21\n 8  2014     1     1       -3     -14 AA      JFK    LAX       356    2475    15\n 9  2014     1     1       -1     -17 AA      JFK    MIA       161    1089    15\n10  2014     1     1       -2     -14 AA      JFK    SEA       349    2422    18\n# … with 253,306 more rows, and abbreviated variable names ¹​dep_delay,\n#   ²​arr_delay, ³​air_time, ⁴​distance\n\nThere are a few commonly used arguments:\ncol_names: if the data doesn’t have column names, you can provide them (or skip them).\ncol_types: set this if the data type of a column is incorrectly inferred by readr\ncomment: if there are comment lines in the file, such as a header line prefixed with #, you want to skip, set this to #.\nskip: # of lines to skip before reading in the data.\nn_max: maximum number of lines to read, useful for testing reading in large datasets.\nThe readr functions will also automatically uncompress gzipped or zipped datasets, and additionally can read data directly from a URL.\nread_csv(\"https://raw.githubusercontent.com/Rdatatable/data.table/master/vignettes/flights14.csv\")\nThere are equivalent functions for writing data from R to files:\nwrite_csv, write_tsv, write_delim.\nData import/export for excel files\nThe readxl package can read data from excel files and is included in the tidyverse. The read_excel() function is the main function for reading data.\nThe openxlsx package, which is not part of tidyverse but is on CRAN, can write excel files. The write.xlsx() function is the main function for writing data to excel spreadsheets.\nData import/export of R objects\nOften it is useful to store R objects on disk. These could be large processed datasets, intermediate results, or complex data structures that are not easily stored in rectangular text formats.\nR provides the readRDS() and saveRDS() functions for storing data in binary formats.\n\n\nsaveRDS(flights, \"flights.rds\") # save single object into a file\ndf <- readRDS(\"flights.rds\") # read object back into R\ndf\n\n# A tibble: 253,316 × 11\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       14      13 AA      JFK    LAX       359    2475     9\n 2  2014     1     1       -3      13 AA      JFK    LAX       363    2475    11\n 3  2014     1     1        2       9 AA      JFK    LAX       351    2475    19\n 4  2014     1     1       -8     -26 AA      LGA    PBI       157    1035     7\n 5  2014     1     1        2       1 AA      JFK    LAX       350    2475    13\n 6  2014     1     1        4       0 AA      EWR    LAX       339    2454    18\n 7  2014     1     1       -2     -18 AA      JFK    LAX       338    2475    21\n 8  2014     1     1       -3     -14 AA      JFK    LAX       356    2475    15\n 9  2014     1     1       -1     -17 AA      JFK    MIA       161    1089    15\n10  2014     1     1       -2     -14 AA      JFK    SEA       349    2422    18\n# … with 253,306 more rows, and abbreviated variable names ¹​dep_delay,\n#   ²​arr_delay, ³​air_time, ⁴​distance\n\nIf you want to save/load multiple objects you can use save() and load().\n\n\nsave(flights, df, file = \"robjs.rda\")  # save flight_df and df\n\n\nload() will load the data into the environment with the same objects names used when saving the objects.\n\n\nrm(flights, df)\nload(\"robjs.rda\")\n\n\nGrammar for data manipulation: dplyr\ndplyr provides a suite of functions for manipulating data\nin tibbles.\n*Rows:\n- filter() chooses rows based on column values\n- slice() chooses rows based on location\n- arrange() changes the order of the rows\n- distinct() selects distinct/unique rows\n*Columns:\n- select() changes whether or not a column is included\n- rename() changes the name of columns\n- mutate() changes the values of columns and creates new columns\nGroups of rows:\n- summarise() collapses a group into a single row\nChaining operations\nThe magrittr package provides the pipe operator %>%. This operator allows you to pass data from one function to another. The pipe takes data from the left-hand operation and passes it to the first argument of the right-hand operation. x %>% f(y) is equivalent to f(x, y). There is now also a pipe operator in base R (|>) which is starting to become more widely used.\nThe pipe allows complex operations to be conducted without having many intermediate variables. Chaining multiple dplyr commands is a very power and readable\n\n\nnrow(flights)\n\n[1] 253316\n\nflights %>% nrow() # get number of rows\n\n[1] 253316\n\nflights %>% nrow(x = .) # the `.` is a placeholder for the data moving through the pipe and is implied\n\n[1] 253316\n\nflights %>% colnames() %>% sort() # sort the column names\n\n [1] \"air_time\"  \"arr_delay\" \"carrier\"   \"day\"       \"dep_delay\" \"dest\"     \n [7] \"distance\"  \"hour\"      \"month\"     \"origin\"    \"year\"     \n\n# you still need to assign the output if you want to use it later\nnumber_of_rows <- flights %>% nrow() \nnumber_of_rows \n\n[1] 253316\n\nFilter rows\nReturning to our flights data. Let’s use filter() to select certain rows.\nfilter(tibble, conditional_expression, ...)\n\n\nfilter(flights, dest == \"LAX\") #select rows where the `dest` column is equal to `LAX\n\n# A tibble: 14,434 × 11\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       14      13 AA      JFK    LAX       359    2475     9\n 2  2014     1     1       -3      13 AA      JFK    LAX       363    2475    11\n 3  2014     1     1        2       9 AA      JFK    LAX       351    2475    19\n 4  2014     1     1        2       1 AA      JFK    LAX       350    2475    13\n 5  2014     1     1        4       0 AA      EWR    LAX       339    2454    18\n 6  2014     1     1       -2     -18 AA      JFK    LAX       338    2475    21\n 7  2014     1     1       -3     -14 AA      JFK    LAX       356    2475    15\n 8  2014     1     1      142     133 AA      JFK    LAX       345    2475    19\n 9  2014     1     1       -4      11 B6      JFK    LAX       349    2475     9\n10  2014     1     1        3     -10 B6      JFK    LAX       349    2475    16\n# … with 14,424 more rows, and abbreviated variable names ¹​dep_delay,\n#   ²​arr_delay, ³​air_time, ⁴​distance\n\n\n\nfilter(flights, arr_delay > 200) # flights with arr_delay > 200\nfilter(flights, distance < 100) # flights less than 100 miles\nfilter(flights, year != 2014) # if no rows satisfy condition, then an empty tibble\n\n\nMultiple conditions can be used to select rows. For example we can select rows where the dest column is equal to LAX and the origin is equal to EWR. You can either use the & operator, or supply multiple arguments.\n\n\nfilter(flights, dest == \"LAX\", origin == \"EWR\")\nfilter(flights, dest == \"LAX\" & origin == \"EWR\")\n\n\nWe can select rows where the dest column is equal to LAX or the origin is equal to EWR using the | operator.\n\n\nfilter(flights, dest == \"LAX\" | origin == \"EWR\")\n\n\nThe %in% operator is useful for identifying rows with entries matching those in a vector of possibilities.\n\n\nfilter(flights, dest %in% c(\"LAX\", \"SLC\", \"SFO\"))\nfilter(flights, !dest %in% c(\"LAX\", \"SLC\", \"SFO\")) # ! will negate\n\n\nTry it out:\nUse filter to find flights to DEN with a delayed departure (dep_delay).\n\n\nfilter(flights, dest == \"DEN\", dep_delay > 0)\n\n# A tibble: 3,060 × 11\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       45      37 B6      JFK    DEN       237    1626    22\n 2  2014     1     1        6     -13 DL      JFK    DEN       235    1626    20\n 3  2014     1     1       13      16 DL      LGA    DEN       242    1620    18\n 4  2014     1     1       35      47 F9      LGA    DEN       246    1620    18\n 5  2014     1     1        2      19 WN      EWR    DEN       259    1605    12\n 6  2014     1     1       17      60 WN      LGA    DEN       245    1620    17\n 7  2014     1     1        3      12 WN      LGA    DEN       260    1620    11\n 8  2014     1     1       10       3 UA      EWR    DEN       224    1605    17\n 9  2014     1     1       46      43 UA      LGA    DEN       235    1620    18\n10  2014     1     1       22       8 UA      EWR    DEN       237    1605     9\n# … with 3,050 more rows, and abbreviated variable names ¹​dep_delay,\n#   ²​arr_delay, ³​air_time, ⁴​distance\n\narrange rows\narrange() can be used to sort the data based on values in a single or multiple columns\narrange(tibble, <columns_to_sort_by>)\nFor example, let’s find the flight with the shortest amount of air time by arranging the table based on the air_time (flight time in minutes).\n\n\narrange(flights, air_time) \n\n# A tibble: 253,316 × 11\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     2    21       46      40 EV      EWR    BDL        20     116     9\n 2  2014     6    20       -6      -2 US      LGA    BOS        20     184    14\n 3  2014     1    16       -3     -12 EV      EWR    BDL        21     116    11\n 4  2014     1    16       10      14 EV      EWR    BDL        21     116     8\n 5  2014     2    19       19       0 EV      EWR    BDL        21     116     8\n 6  2014     2    26       38      20 EV      EWR    BDL        21     116    23\n 7  2014     3     4       17      -4 EV      EWR    BDL        21     116    22\n 8  2014     6     5      105      93 EV      EWR    BDL        21     116    14\n 9  2014     6     5       16       4 EV      EWR    BDL        21     116    22\n10  2014     6    26       19      13 EV      EWR    BDL        21     116    13\n# … with 253,306 more rows, and abbreviated variable names ¹​dep_delay,\n#   ²​arr_delay, ³​air_time, ⁴​distance\n\n\n\narrange(flights, air_time, distance) # sort first on distance, then on air_time\n\n # to sort in decreasing order, wrap the column name in `desc()`.\narrange(flights, desc(air_time), distance)\n\n\nTry it out:\nUse arrange to rank the data by flight distance (distance), rank in ascending order. What flight has the shortest distance?\n\n\narrange(flights, distance) %>% slice(1) \n\n# A tibble: 1 × 11\n   year month   day dep_delay arr_d…¹ carrier origin dest  air_t…² dista…³  hour\n  <dbl> <dbl> <dbl>     <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n1  2014     1    30         9      17 US      EWR    PHL        46      80    15\n# … with abbreviated variable names ¹​arr_delay, ²​air_time, ³​distance\n\nColumn operations\nselect columns\nselect() is a simple function that subsets the tibble to keep certain columns.\nselect(tibble, <columns_to_keep>)\n\n\nselect(flights, origin, dest)\n\n# A tibble: 253,316 × 2\n   origin dest \n   <chr>  <chr>\n 1 JFK    LAX  \n 2 JFK    LAX  \n 3 JFK    LAX  \n 4 LGA    PBI  \n 5 JFK    LAX  \n 6 EWR    LAX  \n 7 JFK    LAX  \n 8 JFK    LAX  \n 9 JFK    MIA  \n10 JFK    SEA  \n# … with 253,306 more rows\n\nthe : operator can select a range of columns, such as the columns from air_time to hour. The ! operator selects columns not listed.\n\n\nselect(flights, air_time:hour)\nselect(flights, !(air_time:hour))\n\n\nThere is a suite of utilities in the tidyverse to help with select columns based on conditions: matches(), starts_with(), ends_with(), contains(), any_of(), and all_of(). everything() is also useful as a placeholder for all columns not explicitly listed. See help ?select\n\n\n# keep columns that have \"delay\" in the name\nselect(flights, contains(\"delay\"))\n\n# select all columns except carrier\nselect(flights, -carrier)\n\n# reorder columns so that distance and hour are first columns\nselect(flights, starts_with(\"di\"), ends_with(\"ay\"))\n\n\nWhen to quote or not quote?\nIn general, when working with the tidyverse, you don’t need to quote the names of columns. In the example above, we needed quotes because “delay” is not a column name in the flights tibble.\nAdding new columns with mutate\nmutate() allows you to add new columns to the tibble.\nmutate(tibble, new_column_name = expression, ...)\n\n\nmutate(flights, total_delay = dep_delay + arr_delay)\n\n# A tibble: 253,316 × 12\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       14      13 AA      JFK    LAX       359    2475     9\n 2  2014     1     1       -3      13 AA      JFK    LAX       363    2475    11\n 3  2014     1     1        2       9 AA      JFK    LAX       351    2475    19\n 4  2014     1     1       -8     -26 AA      LGA    PBI       157    1035     7\n 5  2014     1     1        2       1 AA      JFK    LAX       350    2475    13\n 6  2014     1     1        4       0 AA      EWR    LAX       339    2454    18\n 7  2014     1     1       -2     -18 AA      JFK    LAX       338    2475    21\n 8  2014     1     1       -3     -14 AA      JFK    LAX       356    2475    15\n 9  2014     1     1       -1     -17 AA      JFK    MIA       161    1089    15\n10  2014     1     1       -2     -14 AA      JFK    SEA       349    2422    18\n# … with 253,306 more rows, 1 more variable: total_delay <dbl>, and abbreviated\n#   variable names ¹​dep_delay, ²​arr_delay, ³​air_time, ⁴​distance\n\nWe can’t see the new column, so we add a select command to examine the columns of interest.\n\n\nmutate(flights, total_delay = dep_delay + arr_delay) %>% \n  select(dep_delay, arr_delay, total_delay)\n\n# A tibble: 253,316 × 3\n   dep_delay arr_delay total_delay\n       <dbl>     <dbl>       <dbl>\n 1        14        13          27\n 2        -3        13          10\n 3         2         9          11\n 4        -8       -26         -34\n 5         2         1           3\n 6         4         0           4\n 7        -2       -18         -20\n 8        -3       -14         -17\n 9        -1       -17         -18\n10        -2       -14         -16\n# … with 253,306 more rows\n\nMultiple new columns can be made, and you can refer to columns made in preceding statements.\n\n\nmutate(flights, \n       total_delay = dep_delay + arr_delay,\n       rank_delay = rank(total_delay)) %>% \n  select(total_delay, rank_delay)\n\n\nTry it out:\nCalculate the flight time (air_time) in hours rather than in minutes, add as a new column.\n\n\nmutate(flights, flight_time = air_time / 60)\n\n# A tibble: 253,316 × 12\n    year month   day dep_de…¹ arr_d…² carrier origin dest  air_t…³ dista…⁴  hour\n   <dbl> <dbl> <dbl>    <dbl>   <dbl> <chr>   <chr>  <chr>   <dbl>   <dbl> <dbl>\n 1  2014     1     1       14      13 AA      JFK    LAX       359    2475     9\n 2  2014     1     1       -3      13 AA      JFK    LAX       363    2475    11\n 3  2014     1     1        2       9 AA      JFK    LAX       351    2475    19\n 4  2014     1     1       -8     -26 AA      LGA    PBI       157    1035     7\n 5  2014     1     1        2       1 AA      JFK    LAX       350    2475    13\n 6  2014     1     1        4       0 AA      EWR    LAX       339    2454    18\n 7  2014     1     1       -2     -18 AA      JFK    LAX       338    2475    21\n 8  2014     1     1       -3     -14 AA      JFK    LAX       356    2475    15\n 9  2014     1     1       -1     -17 AA      JFK    MIA       161    1089    15\n10  2014     1     1       -2     -14 AA      JFK    SEA       349    2422    18\n# … with 253,306 more rows, 1 more variable: flight_time <dbl>, and abbreviated\n#   variable names ¹​dep_delay, ²​arr_delay, ³​air_time, ⁴​distance\n\nSummarizing columns\nsummarize() is a function that will collapse the data from a column into a summary value based on a function that takes a vector and returns a single value (e.g. mean(), sum(), median()). It is not very useful yet, but will be very powerful when we discuss grouped operations.\n\n\nsummarize(flights, \n          avg_arr_delay = mean(arr_delay),\n          med_air_time = median(air_time))\n\n# A tibble: 1 × 2\n  avg_arr_delay med_air_time\n          <dbl>        <dbl>\n1          8.15          134\n\nGrouped operations\nAll of the functionality described above can be easily expressed in base R syntax (see examples here). However, where dplyr really shines is the ability to apply the functions above to groups of data within each data frame.\nWe can establish groups within the data using group_by(). The functions mutate(), summarize(), and optionally arrange() will instead operate on each group independently rather than all of the rows.\nCommon approaches:\ngroup_by -> summarize: calculate summaries per group\ngroup_by -> mutate: calculate summaries per group and add as new column to original tibble\ngroup_by(tibble, <columns_to_establish_groups>)\n\n\ngroup_by(flights, carrier) # notice the new \"Groups:\" metadata. \n\n# calculate average dep_delay per carrier\ngroup_by(flights, carrier) %>% \n  summarize(avg_dep_delay = mean(dep_delay)) \n\n# calculate average arr_delay per carrier at each airport\ngroup_by(flights, carrier, origin) %>% \n  summarize(avg_dep_delay = mean(dep_delay)) \n\n# calculate # of flights between each origin and destination city, per carrier, and average air time.\n # n() is a special function that returns the # of rows per group\ngroup_by(flights, carrier, origin, dest) %>%\n  summarize(n_flights = n(),\n            mean_air_time = mean(air_time))  \n\n\nHere are some questions that we can answer using grouped operations in a few lines of dplyr code. Use pipes.\nWhat is the average flight air_time between each origin airport and destination airport?\n\n\ngroup_by(flights, origin, dest) %>% \n  summarize(avg_air_time = mean(air_time))\n\n# A tibble: 221 × 3\n# Groups:   origin [3]\n   origin dest  avg_air_time\n   <chr>  <chr>        <dbl>\n 1 EWR    ALB           31.4\n 2 EWR    ANC          424. \n 3 EWR    ATL          111. \n 4 EWR    AUS          210. \n 5 EWR    AVL           89.7\n 6 EWR    AVP           25  \n 7 EWR    BDL           25.4\n 8 EWR    BNA          115. \n 9 EWR    BOS           40.1\n10 EWR    BQN          197. \n# … with 211 more rows\n\nWhat are the fastest and longest cities to fly between on average?\n\n\ngroup_by(flights, origin, dest) %>% \n  summarize(avg_air_time = mean(air_time)) %>% \n  arrange(avg_air_time) %>% \n  head(1)\n\n# A tibble: 1 × 3\n# Groups:   origin [1]\n  origin dest  avg_air_time\n  <chr>  <chr>        <dbl>\n1 EWR    AVP             25\n\ngroup_by(flights, origin, dest) %>% \n  summarize(avg_air_time = mean(air_time)) %>% \n  arrange(desc(avg_air_time)) %>% \n  head(1)\n\n# A tibble: 1 × 3\n# Groups:   origin [1]\n  origin dest  avg_air_time\n  <chr>  <chr>        <dbl>\n1 JFK    HNL           625.\n\nTry it out:\nWhich carrier has the fastest flight (air_time) on average from JFK to LAX?\n\n# A tibble: 5 × 2\n  carrier flight_time\n  <chr>         <dbl>\n1 DL             328.\n2 UA             328.\n3 B6             328.\n4 AA             330.\n5 VX             333.\n\nWhich month has the longest departure delays on average when flying from JFK to HNL?\n\n# A tibble: 10 × 2\n   month mean_dep_delay\n   <dbl>          <dbl>\n 1     2         52.9  \n 2     1         41.2  \n 3     7          2.48 \n 4     9          1.04 \n 5     8          1.03 \n 6     3         -0.130\n 7    10         -1.73 \n 8     6         -1.76 \n 9     5         -3.52 \n10     4         -4.5  \n\nString manipulation\nstringr is a package for working with strings (i.e. character vectors). It provides a consistent syntax for string manipulation and can perform many routine tasks:\nstr_c: concatenate strings (similar to paste() in base R)str_count: count occurrence of a substring in a stringstr_subset: keep strings with a substringstr_replace: replace a string with another stringstr_split: split a string into multiple pieces based on a string\n\n\nlibrary(stringr)\nsome_words <- c(\"a sentence\", \"with a \", \"needle in a\", \"haystack\")\nstr_detect(some_words, \"needle\") # use with dplyr::filter\nstr_subset(some_words, \"needle\")\n\nstr_replace(some_words, \"needle\", \"pumpkin\")\nstr_replace_all(some_words, \"a\", \"A\")\n\nstr_c(some_words, collapse = \" \")\n\nstr_c(some_words, \" words words words\", \" anisfhlsdihg\")\n\nstr_count(some_words, \"a\")\nstr_split(some_words, \" \")\n\n\nstringr uses regular expressions to pattern match strings. This means that you can perform complex matching to the strings of interest. Additionally this means that there are special characters with behaviors that may be surprising if you are unaware of regular expressions.\nA useful resource when using regular expressions is https://regex101.com\n\n\ncomplex_strings <- c(\"10101-howdy\", \"34-world\", \"howdy-1010\", \"world-.\")\n# keep words with a series of #s followed by a dash, + indicates one or more occurrences.\nstr_subset(complex_strings, \"[0-9]+-\") \n\n# keep words with a dash followed by a series of #s\nstr_subset(complex_strings, \"-[0-9]+\") \n\nstr_subset(complex_strings, \"^howdy\") # keep words starting with howdy\nstr_subset(complex_strings, \"howdy$\") # keep words ending with howdy\nstr_subset(complex_strings, \".\") # . signifies any character\nstr_subset(complex_strings, \"\\\\.\") # need to use backticks to match literal special character\n\n\nLet’s use dplyr and stringr together.\nWhich destinations contain an “LL” in their 3 letter code?\n\n\nlibrary(stringr)\nfilter(flights, str_detect(dest, \"LL\")) %>% \n  select(dest) %>% \n  unique()\n\n# A tibble: 1 × 1\n  dest \n  <chr>\n1 FLL  \n\nWhich 3-letter destination codes start with H?\n\n\nfilter(flights, str_detect(dest, \"^H\")) %>% \n  select(dest) %>% \n  unique()\n\n# A tibble: 4 × 1\n  dest \n  <chr>\n1 HOU  \n2 HNL  \n3 HDN  \n4 HYA  \n\nLet’s make a new column that combines the origin and dest columns.\n\n\nmutate(flights, new_col = str_c(origin, \":\", dest)) %>% \n  select(new_col, everything())\n\n# A tibble: 253,316 × 12\n   new_col  year month   day dep_delay arr_delay carrier origin dest  air_time\n   <chr>   <dbl> <dbl> <dbl>     <dbl>     <dbl> <chr>   <chr>  <chr>    <dbl>\n 1 JFK:LAX  2014     1     1        14        13 AA      JFK    LAX        359\n 2 JFK:LAX  2014     1     1        -3        13 AA      JFK    LAX        363\n 3 JFK:LAX  2014     1     1         2         9 AA      JFK    LAX        351\n 4 LGA:PBI  2014     1     1        -8       -26 AA      LGA    PBI        157\n 5 JFK:LAX  2014     1     1         2         1 AA      JFK    LAX        350\n 6 EWR:LAX  2014     1     1         4         0 AA      EWR    LAX        339\n 7 JFK:LAX  2014     1     1        -2       -18 AA      JFK    LAX        338\n 8 JFK:LAX  2014     1     1        -3       -14 AA      JFK    LAX        356\n 9 JFK:MIA  2014     1     1        -1       -17 AA      JFK    MIA        161\n10 JFK:SEA  2014     1     1        -2       -14 AA      JFK    SEA        349\n# … with 253,306 more rows, and 2 more variables: distance <dbl>, hour <dbl>\n\n\nShow session info\n\n\nsessionInfo()\n\nR version 4.2.0 (2022-04-22)\nPlatform: x86_64-apple-darwin17.0 (64-bit)\nRunning under: macOS Big Sur/Monterey 10.16\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nother attached packages:\n[1] stringr_1.4.1 tibble_3.1.8  dplyr_1.0.10  readr_2.1.2  \n\nloaded via a namespace (and not attached):\n [1] bslib_0.3.1      compiler_4.2.0   pillar_1.8.1     jquerylib_0.1.4 \n [5] tools_4.2.0      bit_4.0.4        digest_0.6.30    downlit_0.4.2   \n [9] jsonlite_1.8.3   evaluate_0.16    memoise_2.0.1    lifecycle_1.0.3 \n[13] pkgconfig_2.0.3  rlang_1.0.6      DBI_1.1.3        cli_3.4.1       \n[17] rstudioapi_0.13  parallel_4.2.0   distill_1.5      yaml_2.3.6      \n[21] xfun_0.32        fastmap_1.1.0    withr_2.5.0      knitr_1.39      \n[25] generics_0.1.3   vctrs_0.4.1      sass_0.4.1       hms_1.1.2       \n[29] bit64_4.0.5      tidyselect_1.2.0 glue_1.6.2       R6_2.5.1        \n[33] fansi_1.0.3      vroom_1.5.7      rmarkdown_2.14   tzdb_0.3.0      \n[37] magrittr_2.0.3   ellipsis_0.3.2   htmltools_0.5.2  assertthat_0.2.1\n[41] utf8_1.2.2       stringi_1.7.8    cachem_1.0.6     crayon_1.5.2    \n\nAcknowledgements and additional references\nThe content of this class borrows heavily from previous tutorials:\nR code style guide:\nhttp://adv-r.had.co.nz/Style.html\nTutorial organization:\nhttps://github.com/sjaganna/molb7910-2019\nOther R tutorials:\nhttps://github.com/matloff/fasteR\nhttps://r4ds.had.co.nz/index.html\nhttps://bookdown.org/rdpeng/rprogdatascience/\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-04T04:23:17+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-10-03-intro-to-r-language/",
    "title": "Class 1: Introduction to the R statistical programming language",
    "description": {},
    "author": [
      {
        "name": "Kent Riemondy",
        "url": "https://github.com/kriemo"
      }
    ],
    "date": "2022-11-29",
    "categories": [],
    "contents": "\n\nContents\nGoals for this class\nWhat is R\nWhy is R a popular language?\nThe R ecosystem\nGetting help\nBuilt-in documentation\nVignettes\nRstudio Cheatsheets\n\nUsing Rmarkdown to conduct data analysis\nUsing R scripts\nOrganizing projects\nOrganizing your code\nUsing R as a calculator\nAssigning values to variables\nVectors and atomic types in R\nTypes\nNA, Inf, and NaN values\nmaking vectors from scratch\nSubsetting vectors in R\nNamed vectors\n\nR operations are vectorized\nFundamental data structures\nmatrix\ndata.frame\nlist\n\nWorkspaces\nCalling functions in R\nReview\nAcknowledgements and additional references\n\n\nThe Rmarkdown for this class is on github\nGoals for this class\nR language history and ecosystem\nReview Rstudio and Rmarkdown documents\nDiscuss analysis and coding best practices\nGetting help and reading R documentation\nReview R basics\nBasic R usage\nData types\nOperators\nVectorization\nData structures\nWorkspaces\nFunctions\n\nWhat is R\nFrom the R core developers:\n\nR is an integrated suite of software facilities for data manipulation, calculation and graphical display. It includes\nan effective data handling and storage facility,\na suite of operators for calculations on arrays, in particular matrices,\na large, coherent, integrated collection of intermediate tools for data analysis,\ngraphical facilities for data analysis and display either on-screen or on hardcopy, and\na well-developed, simple and effective programming language which includes conditionals, loops, user-defined recursive functions and input and output facilities.\n\n\nR, like S, is designed around a true computer language, and it allows users to add additional functionality by defining new functions. Much of the system is itself written in the R dialect of S, which makes it easy for users to follow the algorithmic choices made. For computationally-intensive tasks, C, C++ and Fortran code can be linked and called at run time. Advanced users can write C code to manipulate R objects directly.\n\n\nMany users think of R as a statistics system. We prefer to think of it as an environment within which statistical techniques are implemented. R can be extended (easily) via packages. There are about eight packages supplied with the R distribution and many more are available through the CRAN family of Internet sites covering a very wide range of modern statistics.\n\nWhy is R a popular language?\n\n\n\nFigure 1: R facilitates the data analysis process. From https://r4ds.had.co.nz/explore-intro.html.\n\n\n\nR is a programming language built by statisticians to facilitate interactive exporatory data analysis.\nR comes with (almost) everything you need built in to rapidly conduct data analysis and visualization.\nR has a large following, which makes it easy to find help and examples of analyses.\n- Rstudio Community\n- Bioconductor Support\n- R stackoverflow\nR works out of the box on major operating systems.\nR has a robust package system of packages from CRAN and bioinformatics focused packages from Bioconductor\nPublication quality plots can be produced with ease using functionality in the base R installation or provided by additional packages.\nR has a built in documentation system to make it easy to find help and examples of how to use R functionality.\nIt’s free, open-source, and has been around in it’s first public release since 1993.\nThe R ecosystem\nWhen you download R from CRAN, there are a number of packages included in the base installation (e.g. base, stats, and datasets). You can do effective data analysis with only the base installation (e.g. see fasteR tutorial). However a key strength of R is the 10,000+ user-developed packages which extend base R functionality.\n\n\n\nFigure 2: Major R package repositories and functions used to install packages.\n\n\n\nCRAN is the official R package repository and source for R. The tidyverse (which we will use in subsequent classes) is a set of packages with consistent design principles meant to extend functionality in base R.\nBioconductor hosts and maintains bioinformatics focused packages, built around a set of core data structures and functionality focused on genomics and bioinformatics.\nGithub hosts software for any software project. It is often used to host R packages in development stages and the actively developed source code for R packages.\nGetting help\nBuilt-in documentation\nThe ? operator can be used to pull up documentation about a function. The ?? operator uses a fuzzy search which can pull up help if you don’t remember the exact function name.\n?install.packages\n??install.package\nAlternatively you can click on the help pane and search for help in Rstudio.\nVignettes\nEvery R package includes a vignette to describe the functionality of the package which can be a great resource to learn about new packages.\nThese can be accessed via the vignette() function, or via the help menu in Rstudio.\nvignette(\"dplyr\")\nRstudio Cheatsheets\nSee Help > Cheatsheets for very helpful graphical references.The base R, dplyr, and ggplot2 cheatsheets are especially useful.\nUsing Rmarkdown to conduct data analysis\nRmarkdown is a reproducible framework to create, collaborate, and communicate your work.\nRmarkdown supports a number of output formats including pdfs, word documents, slide shows, html, etc.\nAn Rmarkdown document is a plain text file with the extension .Rmd and contains the following basic components:\nAn (optional) YAML header surrounded by —s.\nChunks of R code surrounded by ```.\nText mixed with simple text formatting like # heading and italics.\n\nRmarkdown documents are executable documents. You can execute the code and render the markdown into html using the render() function, or alternatively by clicking the knit button in Rstudio.\n\n\nlibrary(rmarkdown)\nrender(\"your-rmarkdown.Rmd\")\n\n\nUsing R scripts\nR code can also be executed using R scripts, which have the .R extension. R scripts can only contain R code, not plain text or markdown. R scripts are useful if you have code that you want to run but don’t need the functionality of an Rmarkdown. You can also put custom R functions into an .R script and then use them in another document. The source() function will execute the R code in a Rscript.\n\n\n# can be a path to a .R file or a URL\nsource(\"https://raw.githubusercontent.com/rnabioco/bmsc-7810-pbda/main/_posts/2022-10-03-intro-to-r-language/custom-functions.R\")\n\ngreeting(\"class\")\n\n\nOrganizing projects\nA little bit of time spent upfront organizing your projects will make analyses easier to manage and reproduce.\nUse Rstudio projects. For the course I recommend making a new project for each class.\nUse multiple directories to separate raw data files from the analysis of the data. Organize the analyses with directories names with chronological dates\nHere’s an example organization strategy.\n.\n├── data\n│   ├── 2022-09-flow\n│   ├── 2022-09-rnaseq-1\n│   └── 2022-09-rnaseq-2\n├── docs\n│   └── project-goals.txt\n├── results\n│   ├── 2022-09-01-rnaseq-expt1\n│   │   └── gene-expression-analysis.Rmd\n│   ├── 2022-09-28-rnaseq-expt2\n│   │   └── splicing-analysis.Rmd\n│   └── 2022-10-01-flow-expt1\n│       └── flow-plots.R\n└── src\n    └── rnaseq_pipeline.sh\nSome very good ideas and examples are discussed here:\n\nNoble WS. A quick guide to organizing computational biology projects. PLoS Comput Biol. 2009 Jul;5(7):e1000424. doi: 10.1371/journal.pcbi.1000424.\n\nProvide meaningful names for your files. Consider including ordinal values (e.g. 01, 02, 03) if analyses depend on previous results to indicate ordering of execution.\n# bad\nmodels.R\nanalysis.R\nexplore.R\nanalysis-redo-final-v2.R\n# good\nclean-data.R\nfit-model.R\nplot-data.R\n# better\n01_clean-data.R\n02_fit-model.R\n03_plot-data.R\nOrganizing your code\n\n“Good coding style is like correct punctuation: you can manage without it, butitsuremakesthingseasiertoread.”\n— Hadley Wickham\n\nCode is used to communicate with your computer, but it also is used to communicate with your future self and your colleagues.\nDon’t just write code for yourself right now, instead write your code with the expectation that your future self will need to reread, understand, and modify it in 6 months.\nUse comments to remind yourself what the code does. The # character tells R to ignore a line of text.\n# convert x to zscores\nzs <- (x - mean(x)) / sd(x)\nUse comments to break up long scripts into logical blocks\n# Load data ---------------------------\ndat <- read_csv(\"awesome-data.csv)\ncolnames(dat) <- c(\"sample\", \"color\", \"score\", \"prediction\")\n...\n...\n# modify data -------------------------\ndat <- mutate(dat, result = score + prediction)\n...\n...\n# Plot data ---------------------------\nggplot(dat, aes(sample, score)) + \n  geom_point()\nUse sensible names for variables. Keep them short, but meaningful. Separate words with snake_case (e.g plot_df) or camelCase (plotDf) approach.\n# good\na <- width * height\np <- 2 * width + 2 * height\nmeasurement_df <- data.frame(area = a, perimeter = p)\n# bad\ny <- x1 * x2\nyy <- 2*x1 + 2*x2\ntmp <- data.frame(a = y, b = yy)\nSpace is free in code, use it liberally. Add spaces around operators.\n# Good\naverage <- mean(feet / 12 + inches, na.rm = TRUE)\n\n# Bad\naverage<-mean(feet/12+inches,na.rm=TRUE)\nSplit up complicated operations or long function calls into multiple lines. In general you can add a newline after a comma or a pipe operation (%>%). Indenting the code can also help with readability.\n# good\ndata <- complicated_function(x,\n                             minimizer = 1.4, \n                             sigma = 100,\n                             scale_values = FALSE, \n                             verbose = TRUE, \n                             additional_args = list(x = 100,\n                                                    fun = rnorm))\n# bad\ndata <- complicated_function(x, minimizer = 1.4, sigma = 100, scale_values = FALSE, verbose = TRUE, additional_args = list(x = 100, fun = rnorm))\n#good\nplot_df <- read_csv(\"awesome_data.csv\") %>% \n  select(sample, scores, condition) %>%\n  mutate(norm_scores = scores / sum(scores))\n  \n#bad\nplot_df <- read_csv(\"awesome_data.csv\") %>% select(sample, scores, condition) %>% mutate(norm_scores = scores / sum(scores)) \nRstudio has a shortcuts to help format code\nCode -> Reformat code\nCode -> Reindent lines\nUsing R as a calculator\n\n\n2 + 3 * 5     # Note the order of operations.\n\n[1] 17\n\n3-7           # value of 3-7\n\n[1] -4\n\n3/2           # Division\n\n[1] 1.5\n\n5^2           # 5 raised to the second power\n\n[1] 25\n\nAssigning values to variables\nIn R you can use either the <- or the = operators to assign objects to variables. The <- is the preferred style. If we don’t assign an operation to a variable, then it will be printed then disappear from our environment.\n\n\nx <- 1 + 1\nx # now stores the value 2\n\n[1] 2\n\n\n\nx <- x + 10 \nx + 20\n\n[1] 32\n\nNow, if we use x, what is it’s value?\nVectors and atomic types in R\nAtomic R types are actually vectors of length 1, in contrast to other languages. For example there is no int type, only integer vectors. This is why you see the [1] next to 42 when you print it, which indicates the length of the vector.\n\n\n42\n\n[1] 42\n\nTypes\nR has character, integer, double(aka numeric) and logical vector types.\n\n\ntypeof(1.0)\n\n[1] \"double\"\n\ntypeof(\"1.0\")\n\n[1] \"character\"\n\ntypeof(1)\n\n[1] \"double\"\n\ntypeof(1L)\n\n[1] \"integer\"\n\ntypeof(TRUE)\n\n[1] \"logical\"\n\ntypeof(FALSE)\n\n[1] \"logical\"\n\ntypeof(\"hello world\")\n\n[1] \"character\"\n\nAlso raw and complex types, but we wont use these in the course.\nYou can change the type of a vector, provided that there is a method to convert between types.\n\n\nas.numeric(\"1.0\")\n\n[1] 1\n\nas.numeric(\"hello world\")\n\n[1] NA\n\nas.character(1.5)\n\n[1] \"1.5\"\n\nas.integer(1.5)\n\n[1] 1\n\nas.integer(TRUE)\n\n[1] 1\n\nas.integer(FALSE)\n\n[1] 0\n\nNA, Inf, and NaN values\n\n\n1 / 0\n\n[1] Inf\n\n-( 1 / 0)\n\n[1] -Inf\n\n0 / 0\n\n[1] NaN\n\nNA\n\n[1] NA\n\n\"0\" / 1\n#' Error in \"0\"/1 : non-numeric argument to binary operator\nmaking vectors from scratch\nThe c function concatenates values into a vector.\n\n\nc(1, 2, 3)\n\n[1] 1 2 3\n\nc(TRUE, FALSE, TRUE)\n\n[1]  TRUE FALSE  TRUE\n\nc(\"dog\", \"cat\", \"bird\")\n\n[1] \"dog\"  \"cat\"  \"bird\"\n\nVectors can only have 1 type, so if you supply multiple types c will silently coerce the result to a single type.\n\n\nc(TRUE, 1.9)\n\n[1] 1.0 1.9\n\nc(FALSE, \"TRUE\")\n\n[1] \"FALSE\" \"TRUE\" \n\nc(1L, 2.0, TRUE, \"Hello\")\n\n[1] \"1\"     \"2\"     \"TRUE\"  \"Hello\"\n\nNumeric ranges can be generated using : or seq\n\n\n1:10\n\n [1]  1  2  3  4  5  6  7  8  9 10\n\nseq(0, 1, by = 0.1)\n\n [1] 0.0 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9 1.0\n\nThere are also functions for sampling from various distributions or vectors.\ne.g.\n\n\n# get 5 values from a normal distribution with mean of 0 and sd of 1\nrnorm(5)\n\n[1] -1.2633152 -0.2385732  1.3109761 -0.4006697 -0.8933422\n\n# get 5 values from uniform distribution from 0 to 1\nrunif(5)\n\n[1] 0.9435736 0.6234581 0.9316560 0.5365836 0.2182703\n\n# sample 5 values from a vector\nsample(1:100, 5)\n\n[1] 74 44 14 38 60\n\nSubsetting vectors in R\nR uses 1-based indexing to select values from a vector. The first element of a vector is at index 1. The [ operator can be used to extract (or assign) elements in a vector. Integer vectors or logical vectors can be used to extract values.\n\n\nx <- 30:40\nx[1]\n\n[1] 30\n\nx[2:5]\n\n[1] 31 32 33 34\n\nx[1000]\n\n[1] NA\n\nValues in a vector can be replaced by assignment at specific indexes.\n\n\nx[2] <- 12345\nx\n\n [1]    30 12345    32    33    34    35    36    37    38    39    40\n\nx[3:10] <- 3:10\nx\n\n [1]    30 12345     3     4     5     6     7     8     9    10    40\n\nNamed vectors\nVectors in R can also have names. A named vector allows you to lookup values by name, rather than by position.\n\n\na <- 2:4\nnames(x) <- c(\"a\", \"b\", \"c\")\n\n# alternatively\nx <- c(\"a\" = 2, \"b\" = 3, \"c\" = 4)\n\nx\n\na b c \n2 3 4 \n\nx[\"c\"]\n\nc \n4 \n\nR operations are vectorized\nMost operations in R are vectorized, meaning that the operation will occur on all element of a vector.\nFor example to take the natural log of an element we use the log function.\n\n\nx <- 1:5\nlog(x)\n\n[1] 0.0000000 0.6931472 1.0986123 1.3862944 1.6094379\n\nIf you are used to programming in other languages (e.g C or python) you might have written a for loop to do the same, something like this.\nfor(i in x){ \n  log(i)\n}\nIn R this is generally not necessary. The built in vectorization saves much typing and makes for very compact and efficient code in R. You can write for loops in R (more on this later in the course) however using the built in vectorization is generally a faster and easier to read solution.\nArithmetic (e.g + -, *) and comparisons operators (>, <, ==) are vectorized.\n\n\nx <- 1:5\ny <- 2\n\nx * y\n\n[1]  2  4  6  8 10\n\nx + y\n\n[1] 3 4 5 6 7\n\nx == 3\n\n[1] FALSE FALSE  TRUE FALSE FALSE\n\nx > 5\n\n[1] FALSE FALSE FALSE FALSE FALSE\n\nx < y\n\n[1]  TRUE FALSE FALSE FALSE FALSE\n\nLogical vectors can be used to select values from a vector. This makes it easy to use a comparison operator to filter for specific values.\ne.g:\n\n\nx <- 30:40\nx[x > 35]\n\n[1] 36 37 38 39 40\n\nFundamental data structures\n\n\n\nFigure 3: Ceballos, Maite and Nicolás Cardiel. 2013. Data structure. First Steps in R. https://web.archive.org/web/20200621022950/http://venus.ifca.unican.es/Rintro/dataStruct.html\n\n\n\nmatrix\nA matrix is a 2 dimensional rectangular data structure, where all values have the same type. A matrix is used to store a collection of vectors of the same type and same length. We can subset or assign values to specific rows or columns using the bracket notation [row_index, col_index].\n\n\nm <- matrix(1:25, nrow = 5, ncol = 5)\ntypeof(m)\n\n[1] \"integer\"\n\nm\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,]    1    6   11   16   21\n[2,]    2    7   12   17   22\n[3,]    3    8   13   18   23\n[4,]    4    9   14   19   24\n[5,]    5   10   15   20   25\n\nm[1:2, 1:3] # [row_index, column_index]\n\n     [,1] [,2] [,3]\n[1,]    1    6   11\n[2,]    2    7   12\n\nMatrices can have column names and row names that identify the columns. These names can also be used for subsetting the matrix.\n\n\ncolnames(m) <- LETTERS[1:5]\nrownames(m) <- letters[1:5]\nm\n\n  A  B  C  D  E\na 1  6 11 16 21\nb 2  7 12 17 22\nc 3  8 13 18 23\nd 4  9 14 19 24\ne 5 10 15 20 25\n\n\n\nm[c(\"a\", \"b\"), c(\"C\", \"D\")]\n\n   C  D\na 11 16\nb 12 17\n\ndata.frame\nA data.frame is similar to a matrix, but each column (vector) can have a different type. The same subsetting operators for matrices work on data.frames.\n\n\ndf <- data.frame(vals = 1:4, \n                 ids = c(\"cat\", \"fish\", \"bear\", \"dog\"),\n                 is_mammal = c(TRUE, FALSE, TRUE, TRUE))\ndf\n\n  vals  ids is_mammal\n1    1  cat      TRUE\n2    2 fish     FALSE\n3    3 bear      TRUE\n4    4  dog      TRUE\n\nlist\nA list is a collection of data structures, which can have different types, and each entry can have a different length or type.\n\n\nlst <- list(vals = 1:4, \n            ids = c(\"bear\", \"dog\"),\n            is_valid = TRUE,\n            aux = m)\nlst\n\n$vals\n[1] 1 2 3 4\n\n$ids\n[1] \"bear\" \"dog\" \n\n$is_valid\n[1] TRUE\n\n$aux\n  A  B  C  D  E\na 1  6 11 16 21\nb 2  7 12 17 22\nc 3  8 13 18 23\nd 4  9 14 19 24\ne 5 10 15 20 25\n\nlst[1] # list of length 1\nlst[[1]] # first element of list\nlst[[1]][1] # first value in first element of list\nA data.frame is a specialized form of a list, whereby each list entry is a vector, and all vectors have the same length. There are functions to convert between data structures (e.g. as.list(), as.data.frame(), as.matrix(), as.vector())\n\n\ndf_lst <- as.list(df)\ndf_lst\nas.data.frame(df_lst)\nas.vector(m)\n\n\nWorkspaces\nObjects that we generate get stored in an environment known as the Global Environment. You can see the objects in the global environment using the ls() function, or by clicking on the environment tab in Rstudio.\n\n\nls()\n\n[1] \"a\"   \"df\"  \"lst\" \"m\"   \"x\"   \"y\"  \n\nObjects can be removed from the environment, which can be helpful if you have a large memory object that is no longer needed.\n\n\nbig_matrix <- matrix(1:1e6, nrow = 1e5, ncol = 100)\n# show # of rows and columns\ndim(big_matrix)\n#' [1] 100000    100\n\n# remove matrix from enviroment\nrm(big_matrix)\nbig_matrix\n# 'Error: object 'big_matrix' not found\n\n\n\nWhen you close Rstudio, by default your global R environment is saved to a hidden file called .Rdata in the project directory. When you relaunch rstudio, R objects from your previous environment will be reloaded. This behavior can lead to many problems and we recommend disabling this option \nTo disable this option, go to Rstudio preferences and uncheck the “Restore .RData into workspace at startup” option and select the “Never” option for the “Save workspace to .RData on exit”.\nWe will discuss in later classes how you can save and reload specific R objects and discuss methods to import/export specific data types.\n\nCalling functions in R\nWe have already used some functions e.g. seq, typeof, matrix, as.data.frame. Functions in R have rules for how arguments are specified.\nround(x, digits = 0)\nround: function namex: required argumentdigits: optional argument (Defaults to 0)\n\n\nnums <- c(1.5, 1.4, -1.6, 0.0099)\nround(nums)\n\n[1]  2  1 -2  0\n\nround(nums, digits = 1)\n\n[1]  1.5  1.4 -1.6  0.0\n\nThe positional order of the arguments specifies that nums will be assigned to x. Alternatively you can explicitly provide the argument x = nums.\n\n\nround(x = nums, digits = 1)\n\n[1]  1.5  1.4 -1.6  0.0\n\nround(nums, 1)\n\n[1]  1.5  1.4 -1.6  0.0\n\nround(digits = 1, x = nums)\n\n[1]  1.5  1.4 -1.6  0.0\n\nYou can write your own functions as well. Functions reduce copying and pasting code, which reduces errors and simplifies code by reducing objects in the global environment.\nWe’ll learn more about functions later in the course.\n\n\nadd <- function(x, y, z = 10){\n  x + y + z\n}\nadd(2, 2)\n\n[1] 14\n\nReview\nTo review todays material, do the following:\nFor each section with code, add you own commands. You will learn faster if you try out the code yourself. If you get errors, try to find help, or ask questions in the class slack channel.\nKnit the rmarkdown after you make changes, you may need to install the distill package: (install.packages(\"distill\"))\nAcknowledgements and additional references\nThe content of this class borrows heavily from previous tutorials:\nR code style guide:\nhttp://adv-r.had.co.nz/Style.html\nTutorial organization:\nhttps://github.com/sjaganna/molb7910-2019\nOther R tutorials:\nhttps://github.com/matloff/fasteR\nhttps://r4ds.had.co.nz/index.html\nhttps://bookdown.org/rdpeng/rprogdatascience/\n\n\n\n",
    "preview": {},
    "last_modified": "2022-12-04T04:23:17+00:00",
    "input_file": {}
  },
  {
    "path": "posts/2022-10-03-install-r/",
    "title": "Prerequisite: R installation and Rmarkdown/Rstudio overview",
    "description": {},
    "author": [
      {
        "name": "Kent Riemondy",
        "url": "https://github.com/kriemo"
      }
    ],
    "date": "2022-10-14",
    "categories": [],
    "contents": "\n\nContents\nDownload R\nMacOS\nWindows\nLinux\n\nDownload Rstudio\nDownload compiler tools\nMacOS\nWindows\nLinux\n\nInstalling the tidyverse and Rmarkdown packages\nIntroduction to using Rstudio and Rmarkdown\n(Appendix) Installing packages from other sources\n\nThis article will explain how to install R, Rstudio, and R packages.\nPlease watch the video at the end of the article that gives an overview of using Rstudio and the Rmarkdown format.\nDownload R\nDownload R from CRAN. Go to the CRAN homepage https://cran.r-project.org/. Select the link to download R for your operating system.\nMacOS\nInstall the newest R version (4.2.1). We recommend installing the version for Intel Macs. If you have a Mac with an M1 processor (click the Apple -> About this Mac, see information under chip), we still recommend using the Intel version of R as it is much easier to install packages built for the intel version at this time. Download the .pkg file, open and follow the prompts to install.\nWindows\nSelect the base link, then click Download R-4.2.1 for Windows to download the .exe file. Open this file to install R.\nLinux\nIf you are on linux, then follow the documentation for your linux OS.\nDownload Rstudio\nGo to the Rstudio website and download Rstudio Desktop for your OS.\nOnce downloaded and installed, open up Rstudio to complete the rest of the tutorial.\nDownload compiler tools\nMacOS\nTo install the necessary compilers, we will follow the recommend steps outlined by CRAN: https://mac.r-project.org/tools/\nYou will need to install the xcode command line tools if a package requires compilation. Open Rstudio and click on the “Terminal” pane. Alternatively you can open the Terminal app from /Applications/Utilities/ (or use the search tool to search for terminal)\nType the following into terminal:\nsudo xcode-select --install\nType in your macOS password, press enter and then click “Install”. This download will require ~9Gb. Verify the installation by typing into terminal:\ngcc --version\nWhich should print something similar to this:\n#' gcc (GCC) 4.8.5\n#' Copyright (C) 2015 Free Software Foundation, Inc.\n#' This is free software; see the source for copying conditions.  There is NO\n#' warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\nHere’s a youtube video explainer\nNext you need to install gfortran, which can be obtained from the CRAN instruction site above. We recommend using the intel version of R, so please follow the instructions for Intel Macs and install gfortran using the gfortran-8.2-Mojave.dmg installer.\nOnce you’ve run the gfortran installer the last step is to make sure that this program is in your PATH. This step will make the gfortran program visible to R, and other programs.\nFirst determine which type of shell you have (typically bash or zsh). Execute the following in a terminal (click either on the terminal pane in Rstudio, or open the terminal app in macOS).\necho $SHELL\nIf you see /bin/zsh then make a plain text file called .zshrc in your home directory (e.g. /Users/Your-macOS-username/), if it doesn’t already exist. If instead you see /bin/bash then make a file called .bashrc in your home directory, if it doesn’t already exist. You can use Rstudio to make a new plain-text file (File->New file->Text) or by opening up the Textedit app, then click Format->Make Plain Text.\nAdd the following line of text to the file (and keep any other text if already present).\nexport PATH=$PATH:/usr/local/gfortran/bin\nSave the text file to your home directory. You may need to rename the file after saving to ensure that it doesn’t end with .txt. (e.g. rename .zshrc.txt -> .zshrc). This file will be a hidden file. Hidden files can be seen in the Finder app by pressing Command + Shift + . (period) to toggle on/off visulizaing hidden files.\nClose and reopen Rstudio.\nWindows\nYou need to install Rtools from CRAN. Go to this link and download the exe installer for your OS: https://cran.r-project.org/bin/windows/Rtools/\nLinux\nYou should have a compiler available already.\nInstalling the tidyverse and Rmarkdown packages\nOnce you have R and Rstudio set up, open up Rstudio, then we will install packages. Packages are extensions to the base R installation that provide additionally functionality to the language. In this course we will use packages from the tidyverse, which is a collection of packages commonly used for data science and interactive data analysis. Installing the tidyverse package will install the entire collection of tidyverse packages.\nCRAN is the official R package repository. CRAN has 18,000+ packages, including the tidyverse packages. Packages from CRAN are installed using the install.packages() function. A successful install will only need to be done once for the course.\nOpen Rstudio to launch R. Then in the console pane, execute the following command to install the tidyverse:\ninstall.packages(\"tidyverse\")\n\n\n\nThis command will take a few minutes to run while all of the packages are installed. Package installation will be completed once the > prompt reappears. Once complete, test package installation by loading the package(s)\nlibrary(tidyverse)\nIf successful you will see something like this:\n\n\n\nAn error will look like this (note misspelled package name for demonstration purposes):\n\n\n\nIf loading tidyverse completes without errors then the packages have been installed. You’ll also now see additional packages (ggplot2, dplyr, tidyr) listed under the “Packages” pane.\nIf there is an error installing tidyverse, you’ll likely see the following at the end of the command:\n#' Warning in install.packages :\n#'  installation of package ‘tidyverse’ had non-zero exit status\nIf this happens, contact the course instructors to help troubleshoot the installation issue.\nAnother package that we will use in the course is rmarkdown, to install run:\ninstall.packages(\"rmarkdown\")\nand verify installation by running library(rmarkdown)\nIntroduction to using Rstudio and Rmarkdown\nNow that you have installed R and Rstudio, please watch this video (~20 minutes) that provides an overview of how to use Rstudio IDE and an introduction to the Rmarkdown format.\nintro-to-rstudio.mp4\nintro-to-rstudio.mov\n(Appendix) Installing packages from other sources\nAt this point you will only need to install the tidyverse and rmarkdown packages \nThere are 2 additional commonly used repositories for R packages that you should know about:\nBioconductor is a repository that hosts 2,000+ bioinformatics related packages.\nTo install bioconductor packages you should use the CRAN package BiocManager. BiocManager has a function called install() to install bioconductor packages. For example to install ComplexHeatmap\ninstall.packages(\"BiocManager\")\nlibrary(BiocManager)\ninstall(\"ComplexHeatmap\")\n# or equivalently you could run BiocManager::install(\"ComplexHeatmap\")\nGithub hosts open-source code from millions of software projects. R packages hosted on github can be installed using the remotes package. Packages on github are generally the development version of a package, or a package that has not been contributed to either CRAN or Bioconductor. To install you’ll need to find the organization name and the repository name on github to install.\nFor example to install the LaCroixColorR package:\ninstall.packages(\"remotes\")\nremotes::install_github('johannesbjork/LaCroixColoR')\n\n\n\n",
    "preview": "posts/2022-10-03-install-r/img/install-packages.png",
    "last_modified": "2022-12-04T04:23:17+00:00",
    "input_file": {}
  }
]
